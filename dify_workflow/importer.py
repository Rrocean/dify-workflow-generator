"""
Importer module for converting Dify DSL YAML to Python code.
"""

import yaml
from typing import Dict, Any, List

class DifyImporter:
    """
    Converts a Dify YAML file into a Python script using dify-workflow-generator.
    """
    
    NODE_CLASS_MAP = {
        "start": "StartNode",
        "end": "EndNode",
        "answer": "AnswerNode",
        "llm": "LLMNode",
        "http-request": "HTTPNode",
        "code": "CodeNode",
        "if-else": "IfElseNode",
        "variable-aggregator": "VariableAggregatorNode",
        "template-transform": "TemplateNode",
        "iteration": "IterationNode",
        "knowledge-retrieval": "KnowledgeNode",
        "question-classifier": "QuestionClassifierNode",
        "parameter-extractor": "ParameterExtractorNode",
        "tool": "ToolNode",
        "assigner": "AssignerNode",
        "document-extractor": "DocumentExtractorNode",
        "list-filter": "ListFilterNode",
    }

    def __init__(self, yaml_content: str):
        self.data = yaml.safe_load(yaml_content)
        self.app = self.data.get("app", {})
        self.workflow = self.data.get("workflow", {})
        self.nodes = self.workflow.get("graph", {}).get("nodes", [])
        self.edges = self.workflow.get("graph", {}).get("edges", [])
        self.imports = {"Workflow"}

    def generate_python_code(self) -> str:
        """Generate the complete Python script."""
        
        # 1. Header
        code = [
            "# Generated by dify-workflow-generator importer",
            "from dify_workflow import *"
        ]
        
        # 2. Workflow Init
        name = self.app.get("name", "Imported Workflow")
        mode = self.app.get("mode", "workflow")
        desc = self.app.get("description", "").replace('"', '\\"')
        icon = self.app.get("icon", "ðŸ¤–")
        
        code.append(f"\n# Create Workflow")
        code.append(f'wf = Workflow(')
        code.append(f'    name="{name}",')
        code.append(f'    mode="{mode}",')
        code.append(f'    description="{desc}",')
        code.append(f'    icon="{icon}"')
        code.append(f')')
        
        # 3. Nodes
        code.append(f"\n# Define Nodes")
        node_var_map = {} # map node_id to python variable name
        
        for i, node in enumerate(self.nodes):
            node_data = node.get("data", {})
            node_type = node_data.get("type")
            node_id = node.get("id")
            title = node_data.get("title", f"node_{i}")
            
            # Sanitize title for variable name
            var_name = "".join(c if c.isalnum() else "_" for c in title).lower()
            if var_name[0].isdigit(): var_name = f"n_{var_name}"
            
            # Avoid duplicate var names
            base_var = var_name
            counter = 1
            while var_name in node_var_map.values():
                var_name = f"{base_var}_{counter}"
                counter += 1
            
            node_var_map[node_id] = var_name
            
            class_name = self.NODE_CLASS_MAP.get(node_type, "Node")
            self.imports.add(class_name)
            
            code.append(f"\n# Node: {title}")
            code.append(f"{var_name} = {class_name}(")
            code.append(f'    title="{title}",')
            
            # Generate properties based on type
            props = self._generate_node_properties(node_type, node_data)
            for prop in props:
                code.append(f"    {prop},")
                
            code.append(f")")
            # Force ID to match original for connections to work perfectly
            # code.append(f'{var_name}.id = "{node_id}"') 
            # Actually, better to rely on connection mapping, but forcing ID ensures 
            # var references inside prompts {{#id.var#}} still work if we don't rewrite them.
            # So, let's keep the ID.
            code.append(f'{var_name}.id = "{node_id}"')

        # 4. Add Nodes
        code.append(f"\n# Add Nodes")
        code.append(f"wf.add_nodes([{', '.join(node_var_map.values())}])")
        
        # 5. Connections
        code.append(f"\n# Connect Nodes")
        for edge in self.edges:
            src = edge.get("source")
            tgt = edge.get("target")
            src_handle = edge.get("sourceHandle", "source")
            tgt_handle = edge.get("targetHandle", "target")
            
            if src in node_var_map and tgt in node_var_map:
                line = f"wf.connect({node_var_map[src]}, {node_var_map[tgt]}"
                if src_handle != "source":
                    line += f', source_handle="{src_handle}"'
                if tgt_handle != "target":
                    line += f', target_handle="{tgt_handle}"'
                line += ")"
                code.append(line)
        
        # 6. Export
        code.append(f"\n# Export")
        code.append(f'wf.export("{name.replace(" ", "_").lower()}.yml")')
        
        return "\n".join(code)

    def _generate_node_properties(self, node_type: str, data: Dict[str, Any]) -> List[str]:
        props = []
        
        if node_type == "start":
            vars = data.get("variables", [])
            props.append(f"variables={repr(vars)}")
            
        elif node_type == "end":
            outputs = data.get("outputs", [])
            props.append(f"outputs={repr(outputs)}")
            
        elif node_type == "llm":
            model = data.get("model", {})
            prompt = data.get("prompt_template", [{}])[0].get("text", "")
            # Escape triple quotes
            prompt = prompt.replace('"""', '\\"\\"\\"')
            props.append(f"model={repr(model)}")
            props.append(f'prompt=r"""{prompt}"""')
            
        elif node_type == "http-request":
            props.append(f'url="{data.get("url", "")}"')
            props.append(f'method="{data.get("method", "GET")}"')
            if data.get("body"):
                props.append(f"body={repr(data.get('body'))}")
            if data.get("headers"):
                props.append(f"headers={repr(data.get('headers'))}")
                
        elif node_type == "code":
            props.append(f'language="{data.get("code_language", "python3")}"')
            code_content = data.get("code", "")
            code_content = code_content.replace('"""', '\\"\\"\\"')
            props.append(f'code=r"""{code_content}"""')
            props.append(f"variables={repr(data.get('variables', []))}")
            props.append(f"outputs={repr(data.get('outputs', []))}")
            
        elif node_type == "if-else":
            conds = data.get("conditions", [])
            # Extract inner conditions from the weird Dify logical_operator structure
            if conds:
                # Dify DSL structure is complex here, simplifying for basic import
                # Usually conds[0]['conditions']
                try:
                    inner_conds = conds[0].get("conditions", [])
                    props.append(f"conditions={repr(inner_conds)}")
                    props.append(f'logical_operator="{conds[0].get("logical_operator", "and")}"')
                except:
                    props.append(f"conditions={repr(conds)}")

        elif node_type == "answer":
            props.append(f'answer=r"""{data.get("answer", "")}"""')
            
        elif node_type == "knowledge-retrieval":
            props.append(f"dataset_ids={repr(data.get('dataset_ids', []))}")
            props.append(f"query_variable_selector={repr(data.get('query_variable_selector', []))}")

        # Add generic handlers for others by dumping data fields if needed
        # For now, this covers the main ones.
        
        return props

def import_workflow(yaml_path: str, output_path: str = None):
    """Import a YAML file and write Python code."""
    with open(yaml_path, "r", encoding="utf-8") as f:
        content = f.read()
        
    importer = DifyImporter(content)
    code = importer.generate_python_code()
    
    if output_path:
        with open(output_path, "w", encoding="utf-8") as f:
            f.write(code)
        print(f"Generated Python code at {output_path}")
    else:
        print(code)
